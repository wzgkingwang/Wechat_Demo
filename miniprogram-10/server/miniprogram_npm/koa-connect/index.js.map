{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nconst noop = () => { };\n/**\n * If the middleware function does not declare receiving the `next` callback\n * assume that it's synchronous and invoke `next` ourselves.\n */\nfunction noCallbackHandler(ctx, connectMiddleware, next) {\n    connectMiddleware(ctx.req, ctx.res, noop);\n    return next();\n}\n/**\n * The middleware function does include the `next` callback so only resolve\n * the Promise when it's called. If it's never called, the middleware stack\n * completion will stall.\n */\nfunction withCallbackHandler(ctx, connectMiddleware, next) {\n    return new Promise((resolve, reject) => {\n        connectMiddleware(ctx.req, ctx.res, (err) => {\n            if (err)\n                reject(err);\n            else\n                resolve(next());\n        });\n    });\n}\n/**\n * Returns a Koa middleware function that varies its async logic based on if the\n * given middleware function declares at least 3 parameters, i.e. includes\n * the `next` callback function.\n */\nfunction koaConnect(connectMiddleware) {\n    const handler = connectMiddleware.length < 3 ? noCallbackHandler : withCallbackHandler;\n    return function koaConnect(ctx, next) {\n        return handler(ctx, connectMiddleware, next);\n    };\n}\nmodule.exports = koaConnect;\n"]}